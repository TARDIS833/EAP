# Logic 7_9 문제 분석 및 해결방안

## 검증 대상
- 결과 파일: `/Users/youngick/Downloads/7_9_카페24_변환.xlsx`
- 확인 시트: `변환완료`

---

## 문제 1) `핸드폰` 컬럼 데이터 깨짐

### 증상
`핸드폰` 셀에 아래처럼 Series 문자열이 들어감.
- `수령인 휴대전화 NaN\n수령인 휴대전화 010-xxxx-xxxx Name: ...`

### 원인
7_9에서 추가한 `normalize_cafe24_dataframe()`의 컬럼 리네임 로직이 다음 상황을 만들고 있음.

- 원본에 `핸드폰`, `전화번호`가 동시에 존재
- 둘 다 `수령인 휴대전화`로 리네임됨
- 결과적으로 동일 컬럼명(`수령인 휴대전화`)이 2개 생김
- `build_self_rows()`에서 `r.get("수령인 휴대전화")` 호출 시 단일 값이 아니라 `Series`가 반환됨
- `normalize_text()`가 이 Series를 문자열로 변환하면서 깨진 문자열이 그대로 저장됨

### 해결방안
1. 리네임 전에 우선순위 기반으로 단일 타깃 컬럼을 만든다.
   - 우선순위 예시: `수령인 휴대전화` > `핸드폰` > `전화번호`
2. 이후 중복 생성 방식 리네임을 하지 말고, 아래처럼 명시적으로 생성:
   - `out["수령인 휴대전화"] = first_non_empty(...)`
3. 동일 이름 중복 컬럼이 생겼는지 검증:
   - `if out.columns.duplicated().any():` 즉시 정리/에러 처리

---

## 문제 2) `출고명` 형식 깨짐 (`젤핏P_라벤더포그; 사이즈=S_S`)

### 증상
정상 기대: `젤핏P_라벤더포그_S`
실제 결과: `젤핏P_라벤더포그; 사이즈=S_S`

### 원인
Cafe24 실무 양식의 옵션 값은 다음 형식임.
- `색상=라벤더포그; 사이즈=S`

현재 `parse_self_options()`의 색상 추출 정규식:
- `색상\s*=\s*([^,]+)`

문제는 구분자를 `,`만 경계로 보므로 `;`를 포함한 문자열 전체를 색상으로 잡아버림.
즉 색상값이 `라벤더포그; 사이즈=S`로 오염됨.

### 해결방안
1. 색상 추출 정규식을 세미콜론/슬래시까지 경계로 확장:
   - 예: `색상\s*=\s*([^,;/\)]+)`
2. 사이즈 추출도 동일하게 경계 강화:
   - 예: `사이즈\s*=\s*([^,;/\)]+)`
3. 전처리에서 `;` 기반 key-value 옵션을 먼저 파싱하는 전용 경로 추가:
   - `색상=...; 사이즈=...` 패턴이면 즉시 `(prefix, color, size)` 생성
4. 후처리 안전장치:
   - 색상 문자열에 `사이즈=` 포함 시 경고 로그 + 강제 정제

---

## 문제 3) `수령인 휴대전화` 컬럼도 깨짐

### 증상
`핸드폰`과 동일한 형태의 깨진 문자열 또는 `NaN` 비정상 값 발생

### 원인
집계 단계에서 `수령인 휴대전화`는 `핸드폰`에서 복사되므로,
상류(`핸드폰`)가 깨지면 동일하게 오염됨.

### 해결방안
1. 문제 1의 중복 컬럼/우선순위 처리 먼저 적용
2. `aggregate_and_finalize_self()` 직전, 전화 컬럼 정규화 함수 적용:
   - 문자열 내 `Name:` 포함 시 비정상으로 판단하고 원천값 재선택
3. `핸드폰`/`수령인 휴대전화` 모두 휴대폰 패턴 검증(예: `010-xxxx-xxxx`) 실패 시 fallback

---

## 권장 수정 순서
1. `normalize_cafe24_dataframe()`에서 전화번호 단일화(중복 컬럼 제거)
2. `parse_self_options()`의 `색상/사이즈` 정규식 보정
3. 변환 직전 데이터 유효성 검사 추가
   - 중복 컬럼명 검사
   - `출고명` 내 `; 사이즈=` 문자열 존재 여부 검사
4. 동일 샘플 파일 재변환 후 아래 3개 컬럼 재검증
   - `핸드폰`
   - `수령인 휴대전화`
   - `출고명`
